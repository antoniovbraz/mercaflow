-- ==========================================
-- MERCAFLOW RBAC SYSTEM - SUPABASE COMPLETO
-- ==========================================
-- Baseado na documentação oficial: Custom Claims & RBAC
-- https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac

-- ==========================================
-- 1. CUSTOM TYPES
-- ==========================================

-- Permissions específicas do MercaFlow
CREATE TYPE public.app_permission AS ENUM (
  'users.read',
  'users.write',
  'users.delete',
  'tenants.read', 
  'tenants.write',
  'tenants.delete',
  'platform.admin',
  'platform.super_admin'
);

-- Roles do sistema
CREATE TYPE public.app_role AS ENUM (
  'user',
  'admin', 
  'super_admin'
);

-- ==========================================
-- 2. USER ROLES TABLE
-- ==========================================

-- Tabela para armazenar roles dos usuários
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  UNIQUE (user_id, role)
);

COMMENT ON TABLE public.user_roles IS 'Application roles for each user in MercaFlow';

-- ==========================================
-- 3. ROLE PERMISSIONS TABLE  
-- ==========================================

-- Tabela para definir permissões por role
CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role app_role NOT NULL,
  permission app_permission NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  UNIQUE (role, permission)
);

COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role in MercaFlow';

-- ==========================================
-- 4. INSERIR PERMISSÕES PADRÃO
-- ==========================================

-- Permissões para 'user' (usuário comum)
INSERT INTO public.role_permissions (role, permission) VALUES
  ('user', 'users.read'),
  ('user', 'tenants.read');

-- Permissões para 'admin' (administrador de tenant)  
INSERT INTO public.role_permissions (role, permission) VALUES
  ('admin', 'users.read'),
  ('admin', 'users.write'),
  ('admin', 'users.delete'),
  ('admin', 'tenants.read'),
  ('admin', 'tenants.write');

-- Permissões para 'super_admin' (proprietário da plataforma)
INSERT INTO public.role_permissions (role, permission) VALUES
  ('super_admin', 'users.read'),
  ('super_admin', 'users.write'), 
  ('super_admin', 'users.delete'),
  ('super_admin', 'tenants.read'),
  ('super_admin', 'tenants.write'),
  ('super_admin', 'tenants.delete'),
  ('super_admin', 'platform.admin'),
  ('super_admin', 'platform.super_admin');

-- ==========================================
-- 5. AUTH HOOK FUNCTION
-- ==========================================

-- Função que será chamada pelo Auth Hook para adicionar user_role ao JWT
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
  DECLARE
    claims jsonb;
    user_role public.app_role;
  BEGIN
    -- Fetch the user role from user_roles table
    SELECT role INTO user_role 
    FROM public.user_roles 
    WHERE user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    IF user_role IS NOT NULL THEN
      -- Set the user_role claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    ELSE
      -- Default to 'user' role if no role assigned
      claims := jsonb_set(claims, '{user_role}', '"user"');
    END IF;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified event
    RETURN event;
  END;
$$;

-- Permissões necessárias para o Auth Hook
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

-- Policy para permitir que o auth admin leia user roles
CREATE POLICY "Allow auth admin to read user roles" ON public.user_roles
AS PERMISSIVE FOR SELECT
TO supabase_auth_admin
USING (true);

-- ==========================================
-- 6. AUTHORIZE FUNCTION PARA RLS
-- ==========================================

-- Função para verificar permissões em RLS policies
CREATE OR REPLACE FUNCTION public.authorize(
  requested_permission app_permission
)
RETURNS boolean AS $$
DECLARE
  bind_permissions int;
  user_role public.app_role;
BEGIN
  -- Fetch user role from JWT once and store it
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;

  -- Count matching permissions for the user's role
  SELECT count(*)
  INTO bind_permissions
  FROM public.role_permissions
  WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;

  RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- ==========================================
-- 7. FUNÇÕES HELPER PARA A APLICAÇÃO
-- ==========================================

-- Função para verificar se o usuário é super admin
CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS boolean AS $$
BEGIN
  RETURN (auth.jwt() ->> 'user_role') = 'super_admin';
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- Função para verificar se o usuário é admin ou super admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN (auth.jwt() ->> 'user_role') IN ('admin', 'super_admin');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- Função para obter o role atual do usuário
CREATE OR REPLACE FUNCTION public.current_user_role()
RETURNS text AS $$
BEGIN
  RETURN COALESCE(auth.jwt() ->> 'user_role', 'user');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- ==========================================
-- 8. RLS POLICIES NAS TABELAS EXISTENTES
-- ==========================================

-- Habilitar RLS nas tabelas user_roles e role_permissions
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- Policy para user_roles: usuários podem ver apenas seus próprios roles
CREATE POLICY "Users can view own roles" ON public.user_roles
FOR SELECT TO authenticated
USING (auth.uid() = user_id);

-- Policy para user_roles: super admins podem ver todos os roles
CREATE POLICY "Super admins can view all roles" ON public.user_roles
FOR SELECT TO authenticated
USING (is_super_admin());

-- Policy para user_roles: super admins podem gerenciar roles
CREATE POLICY "Super admins can manage roles" ON public.user_roles
FOR ALL TO authenticated
USING (is_super_admin());

-- Policy para role_permissions: todos podem ler (necessário para authorize function)
CREATE POLICY "Anyone can read role permissions" ON public.role_permissions
FOR SELECT TO authenticated
USING (true);

-- ==========================================
-- 9. TRIGGERS PARA UPDATED_AT
-- ==========================================

-- Função para atualizar updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para user_roles
CREATE TRIGGER on_user_roles_updated
  BEFORE UPDATE ON public.user_roles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- ==========================================
-- 10. FUNÇÃO PARA DEFINIR PRIMEIRO SUPER ADMIN
-- ==========================================

-- Função para promover um usuário a super admin (use com cuidado!)
CREATE OR REPLACE FUNCTION public.promote_to_super_admin(user_email text)
RETURNS boolean AS $$
DECLARE
  target_user_id uuid;
BEGIN
  -- Buscar user_id pelo email
  SELECT id INTO target_user_id 
  FROM auth.users 
  WHERE email = user_email;
  
  IF target_user_id IS NULL THEN
    RAISE EXCEPTION 'User with email % not found', user_email;
  END IF;
  
  -- Remover roles existentes
  DELETE FROM public.user_roles WHERE user_id = target_user_id;
  
  -- Adicionar role super_admin
  INSERT INTO public.user_roles (user_id, role) 
  VALUES (target_user_id, 'super_admin');
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- ==========================================
-- COMENTÁRIOS E DOCUMENTAÇÃO
-- ==========================================

COMMENT ON FUNCTION public.custom_access_token_hook IS 'Auth Hook function to add user_role to JWT claims';
COMMENT ON FUNCTION public.authorize IS 'Check if current user has specific permission for RLS policies';
COMMENT ON FUNCTION public.is_super_admin IS 'Check if current user is super admin';
COMMENT ON FUNCTION public.is_admin IS 'Check if current user is admin or super admin';
COMMENT ON FUNCTION public.current_user_role IS 'Get current user role from JWT';
COMMENT ON FUNCTION public.promote_to_super_admin IS 'Promote user to super admin by email (DANGER: use with caution)';

-- ==========================================
-- EXEMPLO DE USO: DEFINIR PRIMEIRO SUPER ADMIN
-- ==========================================

-- DESCOMENTE E EXECUTE PARA DEFINIR O PRIMEIRO SUPER ADMIN:
-- SELECT public.promote_to_super_admin('seu@email.com');

-- ==========================================
-- FIM DO SCRIPT RBAC
-- ==========================================